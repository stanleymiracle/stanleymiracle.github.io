<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
<!--Converted with LaTeX2HTML 96.1 (Feb 5, 1996) by Nikos Drakos (nikos@cbl.leeds.ac.uk), CBLU, University of Leeds -->
<HTML>
<HEAD>
<TITLE>On the Relations between Computation and Mathematical
  Logic</TITLE>
<META NAME="description" CONTENT="On the Relations between Computation and Mathematical
  Logic">
<META NAME="keywords" CONTENT="basis1">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<LINK REL=STYLESHEET HREF="basis1.css">
</HEAD>
<BODY LANG="EN">
 <A NAME="tex2html164" HREF="node15.html"><IMG WIDTH=24 HEIGHT=24 ALIGN=BOTTOM ALT="next" SRC="next.png"></A> <A NAME="tex2html162" HREF="node12.html"><IMG WIDTH=24 HEIGHT=24 ALIGN=BOTTOM ALT="up" SRC="up.png"></A> <A NAME="tex2html158" HREF="node13.html"><IMG WIDTH=24 HEIGHT=24 ALIGN=BOTTOM ALT="previous" SRC="prev.png"></A>   <BR>
<B> Next:</B> <A NAME="tex2html165" HREF="node15.html">Conclusion: Mathematical Theory of </A>
<B>Up:</B> <A NAME="tex2html163" HREF="node12.html">Relation to Other Formalisms</A>
<B> Previous:</B> <A NAME="tex2html159" HREF="node13.html">Recursive function theory</A>
<BR> <P>
<H2><A NAME="SECTION00042000000000000000">On the Relations between Computation and Mathematical
  Logic</A></H2>
<P>
<A NAME="seclogic">&#160;</A>
<P>
In what follows computation and mathematical logic will each be
taken in a wide sense. The subject of computation is essentially that
of artificial intelligence since the development of computation is in
the direction of making machines carry out ever more complex
and sophisticated processes, i.e. to behave as intelligently as
possible. Mathematical logic is concerned with formal languages,
with the representation of information of various mathematical and
non-mathematical kinds in formal systems, with relations of
logical dependence, and with the process of deduction.
<P>
In discussions of relations between logic and computation there has
been a tendency to make confused statements, e.g. to say that aspect A
of logic is identical with aspect B of computation, when actually
there is a relation but not an identity. We shall try to be precise.
<P>
There is no single relationship between logic and computation
which dominates the others. Here is a list of some of the more
important relationships.<BR>
<P>
1. Morphological parallels
<P>
The formal command languages in which procedures are
described, e.g. ALGOL; the formal languages of mathematical logic,
e.g. first order predicate calculus; and natural languages to some
extent: all may be described morphologically (i.e., one can describe
what a Grammatical sentence is) using similar syntactical terms. In
my opinion, the importance of this relationship has been
exaggerated, because as soon as one goes into what the sentences
mean the parallelism disappears.<BR>
<P>
2. Equivalent classes of problems
<P>
Certain classes of problems about computations are equivalent to
certain classes of problems about formal systems. For example, let
E <IMG WIDTH=4 HEIGHT=12 ALIGN=MIDDLE ALT="tex2html_wrap_inline2009" SRC="img323.gif"  >  be the class of Turing machines with initial tapes,<BR>
<P>
E <IMG WIDTH=4 HEIGHT=12 ALIGN=MIDDLE ALT="tex2html_wrap_inline2011" SRC="img324.gif"  >  be the class of formulas of the first order predicate calculus,<BR>
<P>
E <IMG WIDTH=5 HEIGHT=12 ALIGN=MIDDLE ALT="tex2html_wrap_inline2013" SRC="img325.gif"  >  be the class of general recursive functions,<BR>
<P>
E <IMG WIDTH=6 HEIGHT=12 ALIGN=MIDDLE ALT="tex2html_wrap_inline2015" SRC="img326.gif"  >  be the class of formulas in a universal Post canonical system,<BR>
<P>
E <IMG WIDTH=4 HEIGHT=12 ALIGN=MIDDLE ALT="tex2html_wrap_inline2017" SRC="img327.gif"  >  be a class of each element which is a Lisp S-function <I>f</I> together with a suitable set of arguments  <IMG WIDTH=73 HEIGHT=18 ALIGN=MIDDLE ALT="tex2html_wrap_inline2021" SRC="img328.gif"  > <BR>
<P>
E <IMG WIDTH=4 HEIGHT=12 ALIGN=MIDDLE ALT="tex2html_wrap_inline2023" SRC="img329.gif"  >  be a program for a stored program digital computer.<BR>
<P>
About E <IMG WIDTH=4 HEIGHT=12 ALIGN=MIDDLE ALT="tex2html_wrap_inline2009" SRC="img323.gif"  >  we ask: Will the machine ever stop?
<P>
About E <IMG WIDTH=4 HEIGHT=12 ALIGN=MIDDLE ALT="tex2html_wrap_inline2011" SRC="img324.gif"  >  we ask: Is the formula valid?
<P>
About E <IMG WIDTH=5 HEIGHT=12 ALIGN=MIDDLE ALT="tex2html_wrap_inline2013" SRC="img325.gif"  >  we ask: Is <I>f</I>(0) defined?
<P>
About E <IMG WIDTH=6 HEIGHT=12 ALIGN=MIDDLE ALT="tex2html_wrap_inline2015" SRC="img326.gif"  >  we ask: Is the formula a theorem?
<P>
About E <IMG WIDTH=4 HEIGHT=12 ALIGN=MIDDLE ALT="tex2html_wrap_inline2017" SRC="img327.gif"  >  we ask: Is  <IMG WIDTH=90 HEIGHT=30 ALIGN=MIDDLE ALT="tex2html_wrap_inline2037" SRC="img330.gif"  >  defined?
<P>
About E <IMG WIDTH=4 HEIGHT=12 ALIGN=MIDDLE ALT="tex2html_wrap_inline2023" SRC="img329.gif"  >  we ask: Will the program ever stop?<BR>
<P>
For any pair (E <IMG WIDTH=3 HEIGHT=14 ALIGN=MIDDLE ALT="tex2html_wrap_inline2041" SRC="img331.gif"  > ,E <IMG WIDTH=6 HEIGHT=14 ALIGN=MIDDLE ALT="tex2html_wrap_inline2043" SRC="img332.gif"  > ) we can define a computable map that
takes any one of the problems about elements of E <IMG WIDTH=3 HEIGHT=14 ALIGN=MIDDLE ALT="tex2html_wrap_inline2041" SRC="img331.gif"  >  into a
corresponding problem about an element of E <IMG WIDTH=3 HEIGHT=14 ALIGN=MIDDLE ALT="tex2html_wrap_inline2041" SRC="img331.gif"  >  and which is such that
the problems have the same answer.  Thus, for any Turing machine and
initial tape we can find a corresponding formula of the first order
predicate calculus such that the Turing machine will eventually stop
if and only if the formula is valid.
<P>
In the case of E <IMG WIDTH=4 HEIGHT=12 ALIGN=MIDDLE ALT="tex2html_wrap_inline2023" SRC="img329.gif"  >  if we want strict equivalence the computer must
be provided with an infinite memory of some kind. Practically, any
present computer has so many states, e.g.  <IMG WIDTH=40 HEIGHT=22 ALIGN=BOTTOM ALT="tex2html_wrap_inline2051" SRC="img333.gif"  > , that we cannot
reason from finiteness that a computation will terminate or repeat
before the solar system comes to an end and one is forced to consider
problems concerning actual computers by methods appropriate to
machines with an infinite number of states.
<P>
These results owe much of their importance to the fact that each of
the problem classes is unsolvable in the sense that for each class
there is no machine which will solve all the problems in the
class. This result can most easily be proved for certain classes
(traditionally Turing machine), and then the equivalence permits its
extension to other classes.  These results have been generalized in
various ways. There is the world of Post, Myhill, and others, on
creative sets and the work of Kleene on hierarchies of
unsolvability. Some of this world is of potential interest for
computation even though the generation of new unsolvable classes of
problems does not in itself seem to be of great interest for
computation.<BR>
<P>
3. Proof procedures and proof checking procedures
<P>
The next relation stems from the fact that computers can be used to
carry out the algorithms that are being devised to generate proofs of
sentences in various formal systems. These formal systems may have any
subject matter of interest in mathematics, in science, or concerning
the relation of an intelligent computer program to its
environment. The formal system on which the most work has been done is
the first order predicate calculus which is particularly important for
several reasons. First, many subjects of interest can be axiomatized
within this calculus. Second, it is complete, i.e. every valid formula
has a proof.  Third, although it seems unlikely that the general
methods for the first order predicate calculus will be able to produce
proofs of significant results in the part of arithmetic axiomatizable
in this calculus (or in any other important domain of mathematics),
the development of these general methods will provide a measure of
what must be left to subject-matter-dependent heuristics. It should be
understood by the reader that the first order predicate calculus is
undecidable; hence there is no possibility of a program that will
decide whether a formula is valid. All that can be done is to
construct programs that will decide some cases and will eventually
prove any valid formula but which will run on indefinitely in the case
of certain invalid formulas.
<P>
Proof-checking by computer may be as important as proof
generation. It is part of the definition of formal system that proofs
be machine checkable. In my forthcoming paper [9], I explore the
possibilities and applications of machine checked proofs. Because a
machine can be asked to do much more work in checking a proof than
can a human, proofs can be made much easier to write in such
systems. In particular, proofs can contain a request for the machine
to explore a tree of possibilities for a conventional proof. The
potential applications for computer-checked proofs are very large. For
example, instead of trying out computer programs on test cases until
they are debugged, one should prove that they have the desired
properties.
<P>
Incidentally, it is desirable in this work to use a mildly
more general concept of formal system. Namely, a formal system
consists of a computable predicate
<P>
<P> <IMG WIDTH=349 HEIGHT=20 ALIGN=BOTTOM ALT="displaymath2053" SRC="img334.gif"  > <P>
of the symbolic expressions <I>statement</I> and <EM>Proof</EM>. We say that <EM>Proof</EM> is a
proof of <I>statement</I> provided
<P>
<P> <IMG WIDTH=349 HEIGHT=20 ALIGN=BOTTOM ALT="displaymath2053" SRC="img334.gif"  > <P>
has the value T.
<P>
        The usefulness of computer checked proofs depends both on the
development of types of formal systems in which proofs are easy to
write and on the formalization of interesting subject domains. It
should be remembered that the formal systems so far developed by
logicians have heretofore quite properly had as their objective that
it should be convenient to prove metatheorems about the systems rather
than that it be convenient to prove theorems in the systems.
<P>
4. Use of formal systems by computer programs
<P>
        When one instructs a computer to perform a task one uses a
sequence of imperative sentences. On the other hand, when one
instructs a human being to perform a task one uses mainly declarative
sentences describing the situation in which he is to act. A single
imperative sentence is then frequently sufficient.
<P>
        The ability to instruct a person in this way depends on his
possession of <EM>common-sense</EM> which we shall define as the fact
that we can count on his having available any sufficiently immediate
consequence of what we tell him and what we can presume he already
knows. In my paper [10] I proposed a computer program called the <EM>
Advice Taker</EM> that would have these capabilities and discussed its
advantages. The main problem in realizing the <EM>Advice Taker</EM> has
been devising suitable formal languages covering the subject matter
about which we want the program to think.
<P>
        This experience and others has led me to the conclusion that
mathematical linguists are making a serious mistake in their almost
exclusive concentration on the syntax and, even more specially, the
grammar of natural languages. It is even more important to develop a
mathematical understanding and a formalization of the kinds of
information conveyed in natural language.
<P>
<HR><A NAME="tex2html164" HREF="node15.html"><IMG WIDTH=24 HEIGHT=24 ALIGN=BOTTOM ALT="next" SRC="next.png"></A> <A NAME="tex2html162" HREF="node12.html"><IMG WIDTH=24 HEIGHT=24 ALIGN=BOTTOM ALT="up" SRC="up.png"></A> <A NAME="tex2html158" HREF="node13.html"><IMG WIDTH=24 HEIGHT=24 ALIGN=BOTTOM ALT="previous" SRC="prev.png"></A>   <BR>
<B> Next:</B> <A NAME="tex2html165" HREF="node15.html">Conclusion: Mathematical Theory of </A>
<B>Up:</B> <A NAME="tex2html163" HREF="node12.html">Relation to Other Formalisms</A>
<B> Previous:</B> <A NAME="tex2html159" HREF="node13.html">Recursive function theory</A>
<P><ADDRESS>
<I>John McCarthy <BR>
Wed May  1 20:03:21 PDT 1996</I>
</ADDRESS>
</BODY>
</HTML>

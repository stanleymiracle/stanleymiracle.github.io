<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <title>Local Vars and Environments</title>
    <meta name="generator" content="emacs-wiki.el">
    <meta http-equiv="Content-Type"
	  content="text/html; charset=gb2312">
    <link rev="made" href="mailto:webmaster@wangyin.com">
    <link rel="home" href="WelcomePage.html">
    <link rel="index" href="WikiIndex.html">
    <LINK rel="stylesheet" href="../main.css" media="screen">
  </head>
  <body>
    <h1>Local Vars and Environments</h1>
    <!-- Page published by Emacs Wiki begins here -->






<h2>局部变量</h2>

<p>
使用 let, let*, letrec 都可以在当前环境中构造局部变量。这种
变量的生命会延续到这个环境消失为止。

</p>

<p>
这就像 C 语言里的

</p>

<pre class="example">{  int x = 10;
   int y = 20;

   foo(x,y);
}
</pre>

<p>
但是有一点不同就是，Scheme 的 let 生成的环境是分配在堆里而不
是像 C 那样分配在栈里的。所以 let 的局部变量有可能在 let 的
block 执行完毕以后还继续存在，只要有某些东西引用到它们。

</p>

<p>
这样我们可以制造一些返回函数的函数，这些函数拥有自己的状态记
忆，而这些记忆并不是全局变量，它们有点像 C 函数的 static 变
量。

</p>

<p>
下面是几个例子：

</p>

<pre class="example">(define (function-gen n)
  (let ((local-var 0))
    (lambda ()
      (display &quot;The local-var is &quot;)
      (display local-var)
      (newline)
      (set! local-var (+ 1 local-var)))))

(define f1 (function-gen 0))
(define f2 (function-gen 100))

(f1)
(f2)
</pre>

<p>
函数 function-gen 接受一个参数 n，并且把它保存到自己的局部变
量 local-var. 它返回一个新的函数，这个函数被调用就会打印
local-var 的值，并且把 local-var 的值加 1.

</p>

<p>
我们用 0 和 100 作为参数传递给 function-gen，生成了两个函数 
f1 和 f2. 这是两个起点不同的计数器。f1 从 0 开始，而 f2 从
100 开始。每次被调用两个函数都打印自己的数字，并且加 1.

</p>

<p>
可见，f1 和 f2 所见到的 local-var 是两个不同的空间。也就是说，
每次调用 function-gen，都会由 let 生成一个新的变量
local-var, 这个变量将一直伴随新生成的函数。

</p>

<h2>局部函数</h2>

<p>
一个函数可以有自己配套的局部函数，这些函数可以从外层的 let,
let* 或者 letrec 定义。局部函数的使用可以参考这里： 
<a href="TreeWalkerGenerator.html">TreeWalkerGenerator</a>.

</p>

<h2>图示</h2>

<p>
我找到一个很好的图示，可以示意以下环境的生成。
我们用一个简单一些的例子：

</p>

<pre class="example">(let ((x 10) (y 20))
          (+ x y))
</pre>

<h3>执行前的环境</h3>

<pre class="example">     +-----+        +------+-----+
envt |  * -+-------&gt;|  car |  *--+----&gt; #&lt;proc ...&gt;#
     +-----+        +------+-----+
                    | cons |  *--+----&gt; #&lt;proc ...&gt;#
                    +------+-----+
                    |   +  |  *--+----&gt; #&lt;proc ...&gt;#
                    +------+-----+
                    |      *     |
                           * 
                    |      *     |
                    +------+-----+
                    |  foo |  +--+----&gt; #&lt;proc ...&gt;#
                    +------+-----+
</pre>

<h3>执行中</h3>

<pre class="example">(let ((x 10) (y 20))
          (+ x y))
</pre>

<p>
进入 let 之后，环境变化：

</p>

<pre class="example">                    +-------+-----+
                    |  car  |  +--+----&gt; #&lt;proc ...&gt;#
                    +-------+-----+
                    | cons  |  +--+----&gt; #&lt;proc ...&gt;#
                    +-------+-----+
                    |   +   |  +--+----&gt; #&lt;proc ...&gt;#
                    +-------+-----+
                    |       *     |
                            *
                    |       *     |
                    +-------+-----+
                    |  foo  |  +--+----&gt; #&lt;proc ...&gt;#
                    +-------+-----+
                              /|\
                               |
                               |
                               |
     +-----+        +-------+--+--+
envt |  +--+-------&gt;|[scope]|  *  |
     +-----+        +-------+-----+             +-----+
                    |   x   |  10 |             | bar |
                    +-------+-----+             +-----+    
                    |   y   |  20 |    
                    +-------+-----+    
</pre>

<h3>执行后</h3>

<p>
又回到第一幅图。

</p>

<h3>如果就这么结束了……</h3>

<p>
如果执行 let 后没有任何指针再指向这个环境，那么过一会儿 x, y 
的绑定这个 frame 就会被垃圾回收掉。

</p>

<h3>如果中间生成了一个函数……</h3>

<p>
如果我们的代码不是那么简单，我们在 let 里生成了一个函数。比
如这样：

</p>

<pre class="example">(define (func-gen)
  (let ((x 10) (y 20))
    (lambda (a b)
          (+ x y a b))))

(define bar (func-gen))
</pre>

<p>
func-gen 函数中被调用时，它在 let 空间中生成了一个函数，并且
作为 func-gen 的返回值送到外层，它被绑定到最外层的环境中的 
bar 变量。那么这个函数引用了这个环境，这个 let frame 不会被
回收。

</p>

<p>
bar 如果在外层层环境被调用，那么它的名字绑定环境仍然是 let 
里面的环境。也就是说，它仍然可以使用局部变量 x 和 y!

</p>

<p>
如果我们调用

</p>

<pre class="example">(f 1 2)
</pre>

<p>
就得到结果 33.

</p>

<h2>同时赋值</h2>

<p>
注意 let 里的 binding 是这样产生的。首先，进入 let 时，我们
只看到外层的绑定，然后每个 let 绑定的右边被 eval，然后这些值
被放到临时的一些空间，所有的右边都求值完毕后，这些值被一一赋
给左边的名字。

</p>

<p>
这相当于同时赋值。

</p>

<p>
所以在下面这种情况里，内层的 let 绑定 b 时，实际上使用的是外
层的 x 在计算。

</p>

<pre class="example">(let ((x 10)    ; bindings of x
      (a 20))   ; and a 
 +----------------------------------------------------------+
 | (foo x)                                 scope of outer x |
 | (let ((x (bar))                           and a          |
 |       (b (baz x x)))                                     |
 |  +------------------------------------------------+      |
 |  | (quux x a)                    scope of inner x |      |
 |  | (quux y b)                    and b            | )    |
 |  +------------------------------------------------+      |
 | (baz x a)                                                |
 | (baz x b)                                                | )
 +----------------------------------------------------------+
</pre>
<!-- Page published by Emacs Wiki ends here -->
    <div class="navfoot">
    <hr>
      <table width="100%" border="0" summary="Footer navigation">
	<tr>
	  <td width="33%" align="left">
	    <span class="footdate">最后更新：2003-06-03</span>
	  </td>
	  <td width="60%" align="center">
	    <span class="foothome">
	      <a href="../index.html">王垠的主页</a> / <a href="WelcomePage.html">WiKi首页</a>/<a href="WikiIndex.html">索引</a>/<a href="wiki_frame.html" target=_parent>框架页</a>/<a href="LocalVarsAndEnvironments.html" target=_parent>取消框架</a>
	    </span>
	  </td>
	  <td width="33%" align="right">
	    
	  </td>
	</tr>
      </table>
    </div>


  </body>
</html>

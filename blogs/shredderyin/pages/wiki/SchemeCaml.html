<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <title>Scheme 与 CAML 的比较</title>
    <meta name="generator" content="emacs-wiki.el">
    <meta http-equiv="Content-Type"
	  content="text/html; charset=utf-8">
    <link rev="made" href="mailto:webmaster@wangyin.com">
    <link rel="home" href="WelcomePage.html">
    <link rel="index" href="WikiIndex.html">
    <LINK rel="stylesheet" href="../main.css" media="screen">
  </head>
  <body>
    <h1>Scheme 与 CAML 的比较</h1>
    <!-- Page published by Emacs Wiki begins here -->






<h2>区别</h2>

<h3>类型</h3>

<ul>
<li>Scheme 继承了 LISP 的传统，没有强制的类型检查机制。一个函
  数可以接受任意类型的参数，返回任意类型。这在很多时候是很方
  便的。但是有时可能引起不明不白的错误。但是如果需要，Scheme 
  也可以自己实现类型系统。
</li>
<li>CAML 有强制的类型检查和综合机制。类型检查使得操作更加安
  全，但是缺少了某种灵活性。大部分时候不需要指明对象
  的类型，解释器可以从上下文判断类型。举一个复杂一点的例子：
</li>
</ul>

<pre class="example">#let rec it_list f a = 
    function [] -&gt; a 
           | x::l -&gt; it_list f (f a x) l;;

&gt;it_list : ('a -&gt; 'b -&gt; 'a) -&gt; 'a -&gt; 'b list -&gt; 'a = &lt;fun&gt;
</pre>

<p>
从这里可以看出。CAML 解释器可以判断：it_list 是一个函数，它
接受两个参数，一个是 ('a -> 'b -> 'a) 类型的函数，一个是 'a 
类型的数据，it_list 返回一个函数，这个函数接受一个 'b 类型的
list 作为参数，返回一个 'a 类型的数据。

</p>

<p>
这个判断是怎么做出的呢？解释器首先把 it_list 的参数 a 作为'a 
类型，把 x::l 作为 'b 类型的 list。由于 it_list 有规则 
[]->a, 所以解释器知道 it_list 返回类型应该是接受 'b 类型list 
参数，返回 'a 类型的函数。由于 (f a x) 同时可以作为 it_list 
的第二个参数，所以解释器知道 f 的返回类型应该是 'a。从 (f a
x) 的 a 和 x，解释器可以判断，f 接受两个参数，一个是 'a 类型
的数据，一个是 'b 类型的数据。

</p>

<p>
是否应该使用类型，这个问题不是程序语言自己能够解决的问题。这
涉及到对于自然最基本的理性思想和方法论问题。你怎样看待世界上
的事物？它们具有类型吗？我们怎样处理共性和个性的差别和联系？

</p>

<p>
CAML 强制用户把世界上的事物加以区别，这在很多时候是有用的。
但是有时这样会导致抹煞事物的共性。Scheme 没有提供类型机制，
但是用户可以自己创造类型系统，所以 Scheme 的灵活性要大一些。
但是并不是所有用户都有精力去制造自己的类型系统，所以 CAML 更
适合某些人的需要。

</p>

<h3>Curry</h3>

<p>
Curry 就是一个多元函数接受少量参数，变成一个更少参数的函数。
比如 f(x,y)=x+y-1, 接受一个常数 a，就变成另外一个函数 
f(y)=a+y-1.

</p>

<ul>
<li>CAML 提供了 curry 机制，如果传递的参数少，一个函数就返回另
  外一个含有更少参数的函数，这个函数又可以接受一些参数。直到
  参数数量满足之后，函数才返回计算的结果。比如下面这种Newton
  method 的实现，本来 until 函数接受3个参数，但是最后的语句
  只给了它两句，所以 newton 如果接受两个参数，就会返回一个 
  float->float 类型的函数。它还可以接受3个参数，第三个就被传
  递给 until 返回的那个 float->float 函数作为“初始值”。
</li>
</ul>

<pre class="example">let deriv f x dx = (f(x+.dx) -. f(x)) /. dx;;
let abs x = if x &gt;. 0.0 then x else -. x;;

let newton f epsilon = 
    let rec until p change x = 
        if p(x) then x 
        else until p change (change(x)) in 
        let satisfied y = abs(f y) &lt;. epsilon in 
            let improve y = y -. (f(y) /. (deriv f y epsilon)) 
            in until satisfied improve;;
</pre>

<ul>
<li>Scheme 本身没有 curry 的机制。Scheme 的函数不能根据传递的
  参数的多少进行变化。虽然有宏机制可以扩展出这种功能，但是不
  是每个用户都有精力来自己实现这种功能。
</li>
</ul>
<br>
<!-- Page published by Emacs Wiki ends here -->
    <div class="navfoot">
    <hr>
      <table width="100%" border="0" summary="Footer navigation">
	<tr>
	  <td width="33%" align="left">
	    <span class="footdate">最后更新：2003-08-02</span>
	  </td>
	  <td width="60%" align="center">
	    <span class="foothome">
	      <a href="../index.html">王垠的主页</a> / <a href="WelcomePage.html">WiKi首页</a>/<a href="WikiIndex.html">索引</a>/<a href="wiki_frame.html" target=_parent>框架页</a>/<a href="SchemeCaml.html" target=_parent>取消框架</a>
	    </span>
	  </td>
	  <td width="33%" align="right">
	    
	  </td>
	</tr>
      </table>
    </div>


  </body>
</html>

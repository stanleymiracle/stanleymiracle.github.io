<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <title>Scheme48 Module Experiments</title>
    <meta name="generator" content="emacs-wiki.el">
    <meta http-equiv="Content-Type"
	  content="text/html; charset=utf-8">
    <link rev="made" href="mailto:webmaster@wangyin.com">
    <link rel="home" href="WelcomePage.html">
    <link rel="index" href="WikiIndex.html">
    <LINK rel="stylesheet" href="../main.css" media="screen">
  </head>
  <body>
    <h1>Scheme48 Module Experiments</h1>
    <!-- Page published by Emacs Wiki begins here -->






<p>
这里我们对 Scheme48 的模块操作进行一些实验。

</p>

<h2>选项</h2>

<p>
首先，我们打开 Scheme48 的一个选项：

</p>

<pre class="example">,set load-noisily
</pre>

<p>
这样，加载模块，更改模块 interface 的时候，我们都会得到有益
的信息。

</p>

<h2>定义 structure</h2>

<h3>在 scheme48 交互式解释器(command processor)中我们定义两个 structure: foo 和 bar.</h3>

<pre class="example">,config
(define-interface foo-interface (export foo1 foo2))
(define-structure foo foo-interface
          (open scheme)
          (files foo))

(define-structure bar 
  (export bar1 foo2 foo3 bar/car bar/head bar/cons bar/+ bar/-) 
  (open foo (modify scheme 
                    (prefix bar/) 
                    (alias (car head))
                    (hide cons)
                    (rename (+ -))
             ))
  (files bar)
  )
</pre>

<p>
为了演示模块名字空间的各种操作，写的复杂一些。现在解释一下：

</p>

<ul>
<li>我们首先通过 ,config 命令进入 config 空间，因为只有在这里
  define-structure 和 define-interface 才有含义。
</li>
<li>foo, bar 都被定义为在需要的时候打开文件。通过 (files foo) 
  和 (files bar) 来得到接口的具体定义。
</li>
<li>其中 foo 这个 structure 使用了预先定义的接口对象 
  foo-interface，使用这样的定义有几个好处，我们后来会看到。
</li>
<li>在 bar 的定义中，打开了 foo，这样 foo 中的所有 export 的 
  interface，在bar 中都可以看到了。
</li>
<li>foo 和 bar 都打开了 scheme 这个 structure，因为如果不打开
  它，"define" 这个名字将没有含义，我们几乎不能干任何有用的
  事情。
</li>
<li>bar 不但打开了 scheme，而且把 + 换名为 -, 把 cons 隐藏起来，
  为 car 定义了一个别名 head, 然后把这些都加上前缀 "bar/"。
  这些名字将出现在 bar 的名字空间中。
</li>
<li>bar 使用
</li>
</ul>

<pre class="example">(export bar1 foo2 foo3 bar/car bar/head bar/cons bar/+ bar/-) 
</pre>

<p>
开放了一些名字。我们看到它把 foo 中的 foo3 也开放了。但是现
在 foo-interface 中只开放了 foo1 和 foo2，而没有开放foo3. 使
用 foo3 将会出错，以后我们会看到。

</p>

<h3>大图景</h3>

<p>
看看，现在的情况就是这个样子：

</p>

<p>
<img src="../images/s48module1.png" alt="../images/s48module1.png">

</p>

<h3>模块定义文件</h3>

<p>
define-structure 只定义了接口，而没有定义具体的函数，我们使
用 (files foo) 和 (files bar) 让 Scheme48 在需要这些函数定义
的时候才打开文件。这是定义模块时通常都采用的方法。你也可以就
在 define-structure 里使用 (begin ...) 直接把函数定义在里面，
但是这种方法除了演示，几乎没有人使用。

</p>

<p>
好了，我们使用“正宗”的作法，编辑两个文件：foo.scm 和 bar.scm

</p>

<p>
foo.scm:

</p>

<pre class="example">(define (foo1) (display &quot;this is foo1&quot;))
(define (foo2) (display &quot;this is foo2&quot;))
;(define (foo2) (display &quot;this is foo2, modified&quot;))

(define (foo3) (display &quot;this is foo3&quot;))
</pre>

<p>
文件里 foo2 的两个定义，我们先把第二个注释掉。以后我们要换定
义时就把第一个注释掉，把第二个的注释符号删掉。

</p>

<p>
bar.scm:

</p>

<pre class="example">(bar/define (bar1)
  (bar/display &quot;this is bar1&quot;))

(bar/define (bar2)
  (bar/display &quot;this is bar2&quot;))
</pre>

<p>
注意到，bar.scm 里使用的奇怪的名字 bar/define, 因为我们在
structure bar 的定义中，把 scheme 的所有名字都加上了前缀bar, 
所以在 bar 的 package 中，没有 define 这种名字，只有 
bar/define.

</p>

<h2>加载模块</h2>

<pre class="example">,user
,open bar
</pre>

<p>
我们回到 user 空间，打开 structure bar。我们看到以下信息：

</p>

<pre class="example">[bar bar.scm
Warning: Structure has undefined exports
         #{Structure 177 bar}
         (foo3 bar/cons bar/+)
]
</pre>

<p>
提示我们： bar 想要输出的接口 foo3, bar/cons 和 bar/+ 没有定
义。这是因为：

</p>

<ul>
<li>foo 虽然定义了 foo3，但是它没有开放它作为接口。
</li>
<li>scheme 的 cons 被 bar 定义里的 (hide cons) 隐藏起来看不到
  了。所以加上前缀的 bar/cons 也看不到了。
</li>
<li>scheme 的 + 被 bar 改名为 -, 并且加上了前缀 bar/。所以 bar 
  里只有 bar/-, 而没有 bar/+.
</li>
</ul>

<p>
以后我们会看到这些问题引起的结果。

</p>

<h2>测试开放的接口</h2>

<p>
我们首先来试一下 bar 开放的接口，语句下的注释是应该得到的输
出。

</p>

<pre class="example">(bar/head '(a b c))
; 'a

(bar/car '(a b c))
; 'a

(eq? bar/head car)
; #t
(eq? bar/car car)
; #t
(eq? bar/car bar/head)
; #t
</pre>

<p>
我们看到：

</p>

<ul>
<li>(alias (car head)) 使得 scheme 的 car 有了一个别名 head. 
  加上一个前缀成了 bar/head, 它具有 car 的功能。
</li>
<li>同时我们还有一个函数叫做 bar/car, 它是由 scheme 原来的 car
  在 bar 的 package 里被加上一个前缀 bar/ 而成的。
</li>
<li>通过 eq? 的测试，我们发现，bar/head, bar/car, car 实际上都
  是同一个函数。
</li>
</ul>

<h2>测试没有开放的接口</h2>

<p>
我们试一下一个没有开放的接口 bar/cdr, 结果出错： 

</p>

<pre class="example">(bar/cdr '(a b c))
; Error: undefined variable
;        bar/cdr
;        (package user)

</pre>

<p>
因为当前环境里没有 bar/cdr 这个函数。我们进入  bar package
再试一下：

</p>

<pre class="example">,in bar
(bar/cdr '(a b c))
; bar&gt;
; Error: undefined variable
;        b
;        (package bar)
</pre>

<p>
还是出错，说 b 是没有定义的变量！怪事…… 再来：

</p>

<pre class="example">,open scheme
(bar/cdr '(a b c))
; bar&gt; Newly accessible in bar: (quote)
; bar&gt; '(b c)
</pre>

<p>
我们打开 scheme 之后，发现信息“Newly accessible in bar:
(quote)”， 这说明我们上一个 (bar/cdr '(a b c)) 出错的原因是：
 <em>bar 空间中 "quote" 没有定义</em> ！

</p>

<p>
回想一下，我们已经把 scheme 里的所有名字加了前缀 bar/ 啊！现
在 quote 应该叫做 bar/quote 我们再试试：

</p>

<pre class="example">(bar/cdr (bar/quote (a b c)))
; bar&gt; '(b c)
</pre>

<p>
得到正确结果。原来如此！

</p>

<h2>测试隐藏和改名的接口</h2>

<pre class="example">(bar/cons 10 '(a b c))
; Error: undefined variable
;        bar/cons
;        (package bar)

(bar/+ 2 3)
; Error: undefined variable
;        bar/+
;        (package bar)

(bar/- 2 3)
; 5
</pre>

<p>
解释：

</p>

<ul>
<li>bar/cons 没有含义，因为我们在定义 bar structure 时使用
  (hide cons) 隐藏了 scheme 的 cons, 所以 bar/cons 在 bar
  package 里没有含义。
</li>
<li>bar/+ 没有含义，而 bar/- 具有 + 的功能。因为我们在 bar 的
  定义里，使用 (rename (+ -)) 把 scheme 的 + 改名为 -，再加
  上一个 bar/ 前缀。
</li>
</ul>

<h2>测试名字重定义</h2>

<p>
我们首先试一下，bar 中开放的 foo package 里的函数 foo2:

</p>

<pre class="example">(foo2)
; this is foo2#{Unspecific}
</pre>

<p>
然后我们把 foo.scm 里的 foo2 函数的定义改成：

</p>

<pre class="example">(define (foo2) (display &quot;this is foo2, modified&quot;))
</pre>

<p>
接着运行：

</p>

<pre class="example">,reload-package foo
(foo2)
; this is foo2, modified#{Unspecific}
</pre>

<p>
我们看到我们只 reload 了 foo, 而没有 reload bar, 但是我们通
过 bar 访问 foo2 函数时，函数定义已经改变。

</p>

<p>
这说明 Scheme48 的名字解释具有即时性。这里，我们想要访问
foo2, Scheme48 就在当前环境里寻找 foo2, 发现  foo2 是 bar 开
放的一个接口，那么它就到 bar 里去找，然后发现 foo2 是 foo 里
开放的接口，于是它顺藤摸瓜找到 foo. 执行那里的函数。

</p>

<p>
这种机制似乎每一个函数调用都会费很多周折，会很慢。但是
Scheme48 采用了类似处理器里的 cache with cache invalidation，
不会费很多时间找到函数定义的。

</p>

<h2>测试从源头打开新的接口</h2>

<p>
我们来试一下，使用 foo 定义了却没有开放的函数 foo3：

</p>

<pre class="example">(foo3)
; Error: undefined variable
;        foo3
;        (package bar)
</pre>

<p>
bar 里开放了 foo3, 但是 foo3 是 foo 定义的，foo 并没有开放
foo3。所以通过 bar 访问 foo3 是非法的。

</p>

<p>
那我们把 foo3 加到 foo 的开放接口中试试：

</p>

<pre class="example">,config
(define-interface foo-interface (export foo1 foo2 foo3))

,user
; config&gt; Newly accessible in bar: (foo3)
</pre>

<p>
回到 user 空间，发现提示：bar 空间中可以访问新的名字 foo3.

</p>

<pre class="example">(foo3)
; this is foo3#{Unspecific}
</pre>

<p>
foo3 就可以使用了。

</p>

<p>
现在名字之间的关系就是这样：

</p>

<p>
<img src="../images/s48module2.png" alt="../images/s48module2.png">

</p>

<h2>插一句：单独定义 interface 对象的好处</h2>

<p>
从上面你可以看出我们把 foo-interface 独立出来定义的好处吗？
我们值重新定义了 foo-interface，在里面加入了 foo3 接口，user
空间就自动看到了这个接口。

</p>

<p>
这避免了我们用 define-structure 重新定义 foo structure 的麻
烦。

</p>

<p>
分开定义 interface 还有一个好处就是：如果你的几个 structure
有相同的 interface, 你只需要写一次。

</p>

<p>
而且，把 interface 从 structure 的定义中分出去，代码会更加好
懂。你可以看看 bar 的 structure 定义中，interface 的部分占据
了大量地方，看起来很混淆。

</p>

<h2>测试没有被间接开放的名字</h2>

<p>
我们试试 foo 里定义了，并且也开放了的函数 foo1 能不能使用：

</p>

<pre class="example">(foo1)
; Error: undefined variable
;        foo1
;        (package user)
</pre>

<p>
不行。因为 foo 里的函数都是通过 bar 进入 user 空间的。而 bar
没有开放 foo1. 所以我们在 user 空间访问不到 foo1.

</p>

<p>
那我们打开 foo:
<pre class="example">,open foo
;  Newly accessible in user: (foo1)
(foo1)
; this is foo1#{Unspecific}
</pre>

<p>
发现 foo1 可以访问了。

</p>

<p>
整个测试的代码可以在这里 
<a href="http://learn.tsinghua.edu.cn:8080/2001315450/src/scheme/s48module-test.tar.gz">下载</a>。
</p><!-- Page published by Emacs Wiki ends here -->
    <div class="navfoot">
    <hr>
      <table width="100%" border="0" summary="Footer navigation">
	<tr>
	  <td width="33%" align="left">
	    <span class="footdate">最后更新：2003-10-19</span>
	  </td>
	  <td width="60%" align="center">
	    <span class="foothome">
	      <a href="../index.html">王垠的主页</a> / <a href="WelcomePage.html">WiKi首页</a>/<a href="WikiIndex.html">索引</a>/<a href="wiki_frame.html" target=_parent>框架页</a>/<a href="ModuleExperiment.html" target=_parent>取消框架</a>
	    </span>
	  </td>
	  <td width="33%" align="right">
	    
	  </td>
	</tr>
      </table>
    </div>


  </body>
</html>

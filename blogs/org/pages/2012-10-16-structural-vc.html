<html>
    <head>

        <meta http-equiv="content-type" content="text/html; charset=utf-8" />
        <link href="../styles/main.css" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="http://www.yinwang.org/images/Yc.jpg">

        <title>结构化版本控制</title>

        
        <script type="text/javascript" src="../js/title.js"></script>
    </head>

    <body>
        <div style="margin: 2% 5% 2% 5%">
            <table>
                <tr>
                    <td width="60%">
                        <div style="padding: 2% 8% 5% 8%; border: 1px solid LightGrey;">
                            <h2 onclick="nightOn()">结构化版本控制</h2>
                            
<p>可能已经有人看过这个 <a href="../../yw21/slides/ydiff-slides.pdf">PDF</a>，不过因为我只在另一篇博文里提了一下，而且链接是国内没法访问那种，所以觉得有必要提出来专门说一下。这个 PPT 前面主要是介绍 <a href="2013-04-21-ydiff-structual-comparison.html">ydiff</a> 结构化比较程序的一些技术细节，从28页开始，我开始讲述对一种“结构化版本控制”（structural version control）软件的设想。</p>

<p>通常的版本控制软件(Git, Mercurial, Darcs, ...)都是基于文本的行或者字符，可是对于程序我们可以做得更好。通过对程序文本进行parse，我们可以构造超越现有版本控制软件的机制。这个 PPT 基本上包含如下内容：</p>

<ul>
    <li>如何进行对程序的结构化比较？</li>
    <li>程序的结构化存储会带来什么样的编程工具的发展？</li>
    <li>基于文本的版本控制为什么对于程序来说有一个根本性的错误？</li>
    <li>为什么文本方式的版本控制的某些问题，在结构化的版本控制里根本不存在？</li>
    <li>Darcs 为什么需要 patch theory，而 Git 为什么不用它？</li>
    <li>结构化版本控制的一些未来发展方向。</li>
</ul>

                        </div>
                    </td>
                </tr>
            </table>
        </div>
    </body>
</html>